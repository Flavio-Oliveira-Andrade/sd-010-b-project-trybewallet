{"version":3,"sources":["reducers/user.js","actions/index.js","reducers/wallet.js","reducers/index.js","store/index.js","pages/Login.js","pages/header.js","pages/formWallet.js","pages/Wallet.js","App.js","serviceWorker.js","index.js"],"names":["initialstate","email","userReducer","state","action","type","payload","currencies","expenses","walletReducer","moeda","gasto","rootReducer","combineReducers","user","wallet","store","createStore","composeWithDevTools","applyMiddleware","thunk","Login","props","password","redireciona","handleChange","bind","submit","target","value","name","this","setState","usuario","emailValido","match","senhaValida","length","to","data-testid","placeholder","className","onChange","disabled","onClick","React","Component","connect","dispatch","Header","gastos","soma","forEach","z","Object","values","exchangeRates","cotacao","codein","currency","code","ask","toFixed","Formulario","id","method","tag","description","handleOnChange","handleOnClick","selectMethodFunction","valueFunction","descriptionFunction","fetchDispatch","fetchCoins","gastoAction","gastosAtuaisArray","then","htmlFor","onSubmit","event","preventDefault","map","bt","key","fetch","response","json","USDT","moedaAction","keys","addGastos","Wallet","App","exact","path","component","login","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.dbdb5191.chunk.js","sourcesContent":["// Esse reducer será responsável por tratar as informações da pessoa usuária\n// depois de ter feito muita coisa no login.js e ter feito o dispatch, aí eu venho aqui começar a completar informações.\nimport { PROPER_EMAIL } from '../actions/index'; // veio do index.js da actions\n\nconst initialstate = {\n  email: '',\n}; // aqui é o estado global,\nconst userReducer = (state = initialstate, action) => {\n  switch (action.type) {\n  case PROPER_EMAIL: // é o que tá na action\n    return {\n      ...state, email: action.payload.email, // boto o email aqui porque foi o que coloquei logo acima no initialstate.\n    }; // depois de email: eu tentei usar ...state.email, action.payload.email  mas não deu certo\n  default:\n    return state;\n  }\n};\nexport default userReducer;\n","// Coloque aqui suas actions\n// Os requisitos  2 e 3 pedem que apenas o email validado esteja no estado global, então minha primeira action só foco no email.\nexport const PROPER_EMAIL = 'PROPER_EMAIL'; // IMPORTANTE: É uma boa prática criar uma constante pra armazenar o que será colocado no type. Aí exporto as duas. Essa daqui eu irei importar no REDUCER( nesse caso será o user.js do reducers)\nexport const TODAS_MOEDAS = 'TODAS_MOEDAS'; // Mesma ideia.\nexport const ADICIONA_GASTOS = 'ADICIONA_GASTOS';\n\n// IMPORTANTE: já essa de baixo, eu irei exportar no COMPONENTE(nesse caso, o login.js dentro de pages).\nexport const action = (email) => ({\n  type: PROPER_EMAIL,\n  payload: {\n    email, // esse aqui tem que ser igual o que tá escrito no parâmetro\n  },\n});\nconst moedaAction = (moeda) => ({\n  type: TODAS_MOEDAS,\n  payload: {\n    moeda, //  TEM QUE SER IGUAL AO DO REDUCER( action.payload.moeda). Perdi horas por causa desse erro, tinha colocado nomes diferentes.\n  },\n}); // Pro requisito 7 preciso fazer essa nova action. Exporto essa no componente.\nexport const addGastos = (gasto) => ({\n  type: ADICIONA_GASTOS,\n  gasto,\n});\n\nexport function fetchApiMoeda() { // é essa que vou importar no formWallet(pra usar no mapDispatchToProps)\n  return (dispatch) => {\n    fetch('https://economia.awesomeapi.com.br/json/all').then((response) => response.json()).then((moeda) => {\n      delete moeda.USDT; // assim faço pra deletar essa moeda(req 7 pediu).\n\n      dispatch(moedaAction(Object.keys(moeda)));// o object.keys é pra retornar em array.\n    }); // OBS: nesse fetch eu coloquei o nome moeda como parâmetro, mas poderia ser qualquer outro nome. Não botei moeda por ter que ser igual ao que tá na action. Não precisa ser igual.\n  };\n}\n// essa daqui é pra pegar todas, incluindo o USDT\nexport function fetchAllcoins() {\n  return () => fetch('https://economia.awesomeapi.com.br/json/all').then((response) => response.json()).then((expenses) => expenses);\n}\n","import { TODAS_MOEDAS, ADICIONA_GASTOS } from '../actions/index';\n// Esse reducer será responsável por tratar o todas as informações relacionadas as despesas\nconst initialstate = { // aqui é o estado global(pra parte do wallet).\n  currencies: [],\n  expenses: [],\n};\nconst walletReducer = (state = initialstate, action) => {\n  switch (action.type) {\n  case TODAS_MOEDAS:\n    return {\n      ...state, currencies: action.payload.moeda, // req 7 pede sobre moedas, e não sobre gastos(ainda). Por isso vou usar o currencies. LEMBRANDO: o nome moeda foi o que botei no estado global.\n    };\n  case ADICIONA_GASTOS:\n    return {\n      ...state, expenses: [...state.expenses, action.gasto],\n    }; // talvez desse action.payload ou action.gasto, mas aqui daria errado colocar action.payload.gasto\n  default:\n    return state;\n  }\n};\nexport default walletReducer;\n","// esse é o index da pasta Reducers\nimport { combineReducers } from 'redux';\nimport user from './user';\nimport wallet from './wallet';\n// padrão criar esse combine\nconst rootReducer = combineReducers({\n  user, // veja que tem no import\n  wallet,\n}); // dentro deste combineReducers eu coloquei 2 dentro. Aí tenho que usar o switch e o case nos arquivos destes 2. Aí importei esse 2 aqui,\n\nexport default rootReducer;\n","// aqui eu vou colocar as coisas da store\nimport { createStore, applyMiddleware } from 'redux';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport thunk from 'redux-thunk';\nimport rootReducer from '../reducers';\n\nconst store = createStore(\n// o README me disse pra usar este applyMiddleware(thunk) e também me disse como fazer as importações.\n  rootReducer,\n  composeWithDevTools(\n    applyMiddleware(thunk),\n  ),\n);\nexport default store;\n","// Os requisitos 2 e 3 eu precisei da enorme ajuda do meu colega Alexandre Damasceno. Link do PR dele: https://github.com/tryber/sd-010-b-project-trybewallet/pull/45/commits\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport './Login.css';\nimport { connect } from 'react-redux';\nimport { Redirect } from 'react-router';\nimport { action } from '../actions/index'; // veio do index.js da actions\n\nclass Login extends React.Component {\n  constructor(props) {\n    super(props); // começo deixando o estado com o email e a senha VAZIOS.\n    this.state = {\n      email: '',\n      password: '',\n      redireciona: false,\n    };\n    this.handleChange = this.handleChange.bind(this); // como não usei arron function, aí uso este bind pra função handleChange.\n    this.submit = this.submit.bind(this); // usei bind aqui pelo mesmo motivo\n  } // esses binds eu sempre faço logo depois desse this.state no início. Uso o bind pra cada função que eu criar(caso não use arrowFunction).\n  // aí abaixo dos binds eu elaboro as funções. E chamo essas funções lá no html dentro dos inputs e botões.\n\n  handleChange({ target: { value, name } }) {\n    this.setState({\n      [name]: value,\n    }); // Essa é uma forma de atualizar o estado dos inputs.Quero atualizar o estado na medida que vou digitando nos dois inputs. O name e o value são duas propriedades no html dos inputs. Lembre desta forma de atualizar o state.\n  }\n\n  submit() {\n    const { usuario } = this.props; // tenho que fazer esse props.\n    const { email } = this.state; // vem do state.\n    // tenho que fazer essas desestruturações porque uso as duas pra chamar a função usuario.\n    usuario(email); // aqui tou chamando a função usuario que fiz lá embaixo no dispatch.\n\n    this.setState({\n      redireciona: true,\n    }); // quando clicar no button e chamar a função submit, eu atualizo o estado\n  }\n\n  render() { // aqui irei validar o email como foi pedido no requisito 2.\n    const { email, password, redireciona } = this.state; // tou trazendo do State. Faço isso daqui porque vou usar esses 3 agora abaixo pra validar as coisas.\n    let emailValido = '';\n    if (email.match(/((\\w+)@(\\w+)\\.(\\w+))/i)) { // é padrão isso aqui\n      emailValido = true;\n    }\n    // aqui irei validar a senha como foi pedido no requisito 2.\n    const criterioSenha = 5;\n    let senhaValida = '';\n    if (password.length > criterioSenha) {\n      senhaValida = true; // se for comprimento maior que 5,é porque tá certo.\n    }\n    if (redireciona) {\n      return <Redirect to=\"/carteira\" />;\n    } // se for redirecionar, aí faz esse redirect aí pra dar certo. Lembrando que pra redirecionar, o botão é clicado e aí chama a função submit e já atualiza o estado pra redireciona: true\n    return (\n      <form>\n        <div>\n          <input\n            data-testid=\"email-input\"\n            type=\"email\"\n            name=\"email\" // é bom botar o name porque fica melhor pra fazer o handleChange.\n            placeholder=\"Digite seu email\"\n            className=\"email\"\n            onChange={ this.handleChange } // preciso botar isso aqui pra que ocorra a função ONCHANGE. Esse nome handleChange é nome padrão e genérico.\n          />\n        </div>\n        <div>\n          <input\n            data-testid=\"password-input\"\n            type=\"password\"\n            name=\"password\"\n            placeholder=\" Digite sua senha\"\n            className=\"password\"\n            onChange={ this.handleChange }\n          />\n        </div>\n\n        <button\n          type=\"button\"\n          className=\"firstButton\"\n          disabled={ emailValido === '' || senhaValida === '' }\n          onClick={ () => this.submit() } // ao clicar, chamo a função submit\n        >\n          Entrar\n        </button>\n      </form>\n    // esse disabled é fundamental. Ele recebe um booleano. Se for TRUE, esse button fica DESABILITADO. Pra habilitar, tem que ser false. Ou seja, pra habilitar, as variáveis emailValido e senhaValida não podem ser vazias. Aí sendo false e o botão habilitado, aí entra nos critérios que eu fiz um pouco acima pra ver se os dois inputs estão com os critérios certinhos.\n    );\n  }\n}\nLogin.propTypes = {\n  usuario: PropTypes.func.isRequired,\n};\nconst mapDispatchToProps = (dispatch) => ({\n  usuario: (email) => dispatch(action(email)), // esse usuario(nome que dei) é UMA FUNÇÃO, tanto que botei assim no propTypes. E o email nos parênteses vem do state.Eu irei chamar essa função DENTRO DA FUNÇÃO SUBMIT.\n}); // tenho que botar essa função usuario(nome que eu dei) como props. Aí é legal fazer dentro da função de submit\n// action foi o nome que dei pra action e exportei ela no index da pasta actions(meu segundo exporte lá). Esse nome email eu coloquei dentro de payload naquele arquivo.\n// o mapDispatch serve pra despachar a action\nexport default connect(null, mapDispatchToProps)(Login); // boto null pq não usei o mapToState aqui. Aqui faço uma conexão\n\n// Depois de ter feito isso aqui, aí agora devo ir no reducer. Neste caso, somente no user.js  O wallet.js não tem relação com o que os requisitos 2 e 3 pedem ainda.\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\n\nclass Header extends React.Component {\n  render() {\n    const { email, gastos } = this.props; // Nessa props o email tá sendo uma string. Vou ter que usar pro elemento que exibe o email de quem fez o login. Essa props TÁ VINDO DO ESTADO GLOBAL, lá no user do reducers, em initialstate\n    // aqui embaixo vou fazer essa sequência(que achei bem complexo) pra poder fazer a soma das despesas, na medida que vou clicando em Adicionar Despesa.\n    let soma = 0;\n    gastos.forEach((z) => {\n      Object.values(z.exchangeRates).forEach((cotacao) => {\n        if (cotacao.codein !== 'BRLT' && z.currency === cotacao.code) {\n          soma += z.value * cotacao.ask;\n        }\n      });\n    });\n    return (\n      <div>\n        <p data-testid=\"email-field\">{ email }</p>\n        <p data-testid=\"total-field\">{soma === 0 ? 0 : (soma).toFixed(2)}</p>\n        <p data-testid=\"header-currency-field\">BRL</p>\n      </div> // nesse meu segundo P, eu fiz um ternário pra colocar as casas decimais na soma\n    );\n  }\n}\nconst mapStateToProps = (state) => ({\n  gastos: state.wallet.expenses,\n});\nHeader.propTypes = {\n  email: PropTypes.string.isRequired,\n  gastos: PropTypes.arrayOf(PropTypes.arrayOf).isRequired,\n};\n\nexport default connect(mapStateToProps, null)(Header);\n","// O requisito 8 eu tive a imensa ajuda do meu colega Alexandre Damasceno. Link do PR dele: https://github.com/tryber/sd-010-b-project-trybewallet/pull/45/files\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport './Login.css';\nimport PropTypes from 'prop-types';\nimport { fetchApiMoeda, fetchAllcoins, addGastos } from '../actions';\n\nclass Formulario extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { // criei esse estado aqui pro requisito 8. Foi baseado no readme.\n      id: '',\n      value: '',\n      currency: '',\n      method: '',\n      tag: '',\n      description: '',\n      exchangeRates: {},\n    };\n    this.handleOnChange = this.handleOnChange.bind(this);\n    this.handleOnClick = this.handleOnClick.bind(this);\n    this.selectMethodFunction = this.selectMethodFunction.bind(this); // essa função foi pra não dar erro no lint por causa de muita linha no Render().\n    this.valueFunction = this.valueFunction.bind(this);\n    this.descriptionFunction = this.descriptionFunction.bind(this);\n  }\n\n  componentDidMount() {\n    const { fetchDispatch } = this.props; // veio do mapDispatch\n    fetchDispatch(); // quando eu chamo essa função, eu chamo a API\n  } // O requisito 7 pede: Ao entrar no /carteira, deve ser feita uma requisição pra API. Então tem que ter esse componentDidMount logo aqui.\n\n  handleOnChange({ target: { name, value } }) {\n    this.setState({\n      [name]: value,\n    });\n  }\n\n  handleOnClick() {\n    const { fetchCoins, gastoAction, gastosAtuaisArray } = this.props;\n    fetchCoins().then((expenses) => this.setState({\n      exchangeRates: expenses,\n      id: gastosAtuaisArray.length,\n    })).then(() => gastoAction(this.state)); // A utilidade disso aqui é: Quando eu clicar no botão, eu tenho que fazer tudo isso aqui e serve pra ATUALIZAR aquele meu estado, na parte do expenses =[].\n  }\n\n  selectMethodFunction() {\n    return (\n\n      <label htmlFor=\"method\">\n        Método de pagamento\n        <select\n          id=\"method\"\n          name=\"method\"\n          className=\"method\"\n          onChange={ this.handleOnChange }\n        >\n          <option value=\"Dinheiro\">Dinheiro</option>\n          <option value=\"Cartão de crédito\">Cartão de crédito</option>\n          <option value=\"Cartão de débito\">Cartão de débito</option>\n        </select>\n      </label>\n\n    );\n  }\n\n  valueFunction() {\n    return (\n\n      <label htmlFor=\"value\">\n        Valor\n        <input\n          id=\"value\"\n          type=\"text\"\n          name=\"value\"\n          className=\"value\"\n          onChange={ this.handleOnChange }\n        />\n      </label>\n\n    );\n  }\n\n  descriptionFunction() {\n    return (\n\n      <label htmlFor=\"description\">\n        Descrição\n        <input\n          id=\"description\"\n          type=\"text\"\n          name=\"description\"\n          className=\"description\"\n          onChange={ this.handleOnChange }\n        />\n      </label>\n\n    );\n  }\n\n  render() {\n    const { currencies } = this.props; // chamo props aqui por causa do MapState. E vou usar aqui pra fazer um map na option da Moeda. Farei um Map e currencies é um Array. ATENÇÃO no map que eu fiz. Veja que é diferente do Resto do formulário. Quando uso o currencies ali, eu estou acessando as currencies na API.\n    return (\n      <section>\n        <form onSubmit={ (event) => event.preventDefault() }>\n          { this.valueFunction() }\n          { this.descriptionFunction() }\n\n          <label htmlFor=\"currency\">\n            Moeda\n            <select\n              id=\"currency\"\n              name=\"currency\"\n              className=\"currency\"\n              onChange={ this.handleOnChange }\n            >\n              {currencies.map((bt) => <option value={ bt } key={ bt }>{ bt }</option>)}\n            </select>\n          </label>\n\n          { this.selectMethodFunction() }\n          <label htmlFor=\"tag\">\n            Tag:\n            <select id=\"tag\" name=\"tag\" className=\"tag\" onChange={ this.handleOnChange }>\n              <option value=\"Alimentação\">Alimentação</option>\n              <option value=\"Lazer\">Lazer</option>\n              <option value=\"Trabalho\">Trabalho</option>\n              <option value=\"Tranporte\">Transporte</option>\n              <option value=\"Saúde\">Saúde</option>\n            </select>\n          </label>\n\n          <button\n            type=\"submit\"\n            className=\"secondButton\"\n            onClick={ this.handleOnClick }\n          >\n            Adicionar despesa\n          </button>\n\n        </form>\n      </section>\n    ); // ATENÇÃO no map que eu fiz. Ele que faz aquele select aparecer diversas moedas de uma forma dinâmica, algo bem interessante.\n  } // OBS IMPORTANTE: No select da moeda, perdi muitas e muitas horas porque tinha colocado o name=currencies, isso fazia a soma das despesas dar errado. Tinha que ser currency. Quando ajeitei, aí deu certo.\n}\nFormulario.propTypes = {\n  currencies: PropTypes.arrayOf.isRequired,\n  fetchDispatch: PropTypes.func.isRequired,\n  gastosAtuaisArray: PropTypes.func.isRequired,\n  fetchCoins: PropTypes.func.isRequired,\n  gastoAction: PropTypes.func.isRequired,\n};\nconst mapStateToProps = (state) => ({\n  currencies: state.wallet.currencies,\n  gastosAtuaisArray: state.wallet.expenses,\n}); // veja lá no index do reducers que currencies É UM ARRAY. Vou botar ela como props lá pra cima, e logo aqui em cima colocarei arrayOf no Proptypes\nconst mapDispatchToProps = (dispatch) => ({\n  fetchDispatch: () => dispatch(fetchApiMoeda()), // esse com chamada de API fica um pouco diferente do outro que fiz no Login.js. Não coloquei nada nos ().\n  fetchCoins: () => dispatch(fetchAllcoins()), // essa é pra aquela outra fetch que fiz, que aí pega todas as moedas.\n  gastoAction: (gasto) => dispatch(addGastos(gasto)), // aqui foi na action que eu fiz e que trouxe pra esse mapDispatch também.\n}); // esse fetchDispatch(nome que inventei) é uma função. Vou botar ela como função lá pra cima, e aqui logo em cima no Proptypes colocarei como func\nexport default connect(mapStateToProps, mapDispatchToProps)(Formulario);\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport Header from './header';\nimport Formulario from './formWallet';\n\nclass Wallet extends React.Component {\n  render() {\n    const { email } = this.props; // pra poder usar email como props.\n    return (\n      <div>\n        <Header email={ email } />\n        <Formulario />\n      </div>\n    ); // Header é o cabeçalho que fiz, e aí trago pra cá o email de novo como props. Usei email como props no meu componente Header. Quero que o email apareça no cabeçalho, então preciso pegar ele no estado global.\n  }\n}\nWallet.propTypes = {\n  email: PropTypes.string.isRequired,\n};\n// o mapStateToProps é pra que a gente consiga pegar os valores que estão nos estados globais\nconst mapStateToProps = (state) => ({\n  email: state.user.email,\n}); // essa é a estrutura do mapStateToProps. O email vem do estado global  e aqui eu trouxe por Props. O user foi onde eu defini que o email tá no estado global. Por isso state.user.email\nexport default connect(mapStateToProps, null)(Wallet);\n","import React from 'react';\nimport { Switch, Route } from 'react-router';\nimport login from './pages/Login';\nimport Wallet from './pages/Wallet';\n// essa estrutura de Rotas faz aqui no APP.JS\n\nfunction App() {\n  return (\n    <Switch>\n      <Route exact path=\"/\" component={ login } />\n      <Route exact path=\"/carteira\" component={ Wallet } />\n    </Switch>\n  ); // o componente Wallet é o dentro de pages, com W maiúsculo. Não é o dentro de reducers com w minúsculo.\n  // perdi 1 hora no REQ 4 porque não tinha colocado o exact antes do path. Era isso que não tava fazendo a rota dar certo quando colocava /carteira\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","// nesse index.js QUE NÃO ESTÁ DENTRO das pastas reducers,pages ou actions eu coloco o BrowserRouter e o Provider por cima do APP. Também devo usar o store dentro do Provider e aí criar uma pasta Store dentro de SRC.\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { BrowserRouter } from 'react-router-dom';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <BrowserRouter>\n    <Provider store={ store }>\n      <App />\n    </Provider>\n  </BrowserRouter>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}